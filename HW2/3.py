# Сложность алгоритма Q(m*n)
# Алгоритм использует динамическое программирование для подсчета количества уникальных путей до правого нижнего угла сетки, с учетом препятствий.
# Инициализируется двумерный массив dp размером m x n, заполненный нулями.
# Значение dp[0][0] инициализируется в зависимости от наличия препятствия в начальной клетке.
# Затем происходит заполнение значений для первого столбца и первой строки.
# Для каждой клетки сетки (кроме начальной), если в этой клетке нет препятствия, то значение dp[i][j] вычисляется как сумма значений сверху (dp[i-1][j]) и слева (dp[i][j-1]).
# После завершения циклов, dp[m-1][n-1] содержит количество уникальных путей до правого нижнего угла сетки.
# Значение возвращается в качестве результата.

def uniquePathsWithObstacles(obstacleGrid) -> int:
    m, n = len(obstacleGrid), len(obstacleGrid[0])  # Получаем количество строк (m) и столбцов (n) в сетке
    dp = [[0] * n for _ in range(m)]  # Создаем двумерный массив размером m x n, заполненный нулями
    dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0  # Инициализируем значение начальной клетки в зависимости от присутствия препятствия

    # Заполняем значения для первого столбца
    for i in range(1, m):
        if obstacleGrid[i][0] == 0:
            dp[i][0] = dp[i-1][0]

    # Заполняем значения для первой строки
    for j in range(1, n):
        if obstacleGrid[0][j] == 0:
            dp[0][j] = dp[0][j-1]

    # Заполняем остальные значения в сетке
    for i in range(1, m):
        for j in range(1, n):
            if obstacleGrid[i][j] == 0:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[m-1][n-1]  # Возвращаем количество уникальных путей до правого нижнего угла сетки
