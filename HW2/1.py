# Сложность алгоритма: O(m*n)
# Функция countSquares принимает матрицу и возвращает количество квадратных подматриц с единицами.
# Если матрица пуста, возвращается 0.
# Определяются количество строк (m) и столбцов (n) в матрице.
# Итерация происходит со второй строки и столбца.
# Для каждой ячейки обновляется значение, умножая его на минимальное значение из трех соседних ячеек и добавляя 1.
# После обхода всех ячеек возвращается сумма всех элементов матрицы, представляющая количество квадратных подматриц с единицами.
# Пример использования: определена матрица, вызывается функция countSquares и выводится результат - количество квадратных подматриц с единицами в матрице.

def countSquares(matrix) -> int:
    # Проверяем, пустая ли матрица
    if not matrix:
        return 0
    
    # Получаем количество строк и столбцов в матрице
    m = len(matrix)
    n = len(matrix[0])
    
    # Проходимся по матрице, начиная со второй строки и второго столбца
    # Примечание: Начинаем со второй строки и столбца, так как первая строка и столбец остаются неизменными
    for i in range(1, m):
        for j in range(1, n):
            # Обновляем текущую ячейку, умножая ее на минимальное значение среди ее левого, верхнего и диагонального соседей,
            # и добавляя 1. Это представляет размер наибольшей квадратной подматрицы, которую можно образовать, используя текущую ячейку.
            matrix[i][j] *= min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1
    
    # Возвращаем сумму всех элементов в матрице, которая представляет общее количество квадратных подматриц с единицами.
    return sum(map(sum, matrix))

# Пример использования:
matrix = [
  [0, 1, 1, 1],
  [1, 1, 1, 1],
  [0, 1, 1, 1]
]
print(countSquares(matrix))
