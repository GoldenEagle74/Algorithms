# Временная сложность алгоритма: O(N), где N - количество узлов в дереве.

# Алгоритм работает следующим образом:
# 1. Создается пустой список "values", в котором будут храниться значения узлов дерева в порядке возрастания.
# 2. Определяется вспомогательная функция "inorderTraversal", которая рекурсивно обходит дерево в порядке возрастания и добавляет значения узлов в список "values".
# 3. Выполняется обход дерева с помощью вызова "inorderTraversal(root)", где "root" - корень дерева.
# 4. Инициализируется переменная "min_diff" значением бесконечности. Она будет использоваться для хранения минимальной разницы между значениями узлов.
# 5. Выполняется цикл от 1 до длины списка "values".
# 6. В каждой итерации цикла вычисляется разница между текущим и предыдущим значением списка "values".
# 7. Если полученная разница меньше текущего значения "min_diff", то "min_diff" обновляется.
# 8. По завершении цикла возвращается значение "min_diff" - минимальная разница между значениями узлов в дереве.


# Определяем класс для узла дерева
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def minDiffInBST(root):
    # Список для хранения значений узлов в порядке возрастания
    values = []
    
    # Функция для обхода дерева в порядке возрастания
    def inorderTraversal(node):
        if node is None:
            return
        inorderTraversal(node.left)
        values.append(node.val)
        inorderTraversal(node.right)
    
    # Выполняем обход дерева
    inorderTraversal(root)
    
    # Инициализируем минимальную разницу значений большим числом
    min_diff = float('inf')
    
    # Вычисляем минимальную разницу между значениями узлов
    for i in range(1, len(values)):
        diff = values[i] - values[i-1]
        min_diff = min(min_diff, diff)
    
    # Возвращаем минимальную разницу
    return min_diff
