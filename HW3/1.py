# Временная сложность: O(n)
# Алгоритм:
# 1. Создаем пустой массив `values`, который будет содержать значения узлов списка.
# 2. Инициализируем указатель `current` на голову списка.
# 3. Пока `current` не станет равным None (до конца списка), выполняем следующие шаги:
#     - Добавляем значение текущего узла `current.val` в массив `values`.
#     - Перемещаем указатель `current` на следующий узел `current.next`.
# 4. Сравниваем массив `values` со своим обратным порядком `values[::-1]`.
# 5. Возвращаем результат сравнения (True, если массив является палиндромом, и False в противном случае).


def isPalindrome(head):
    # Преобразуем список в массив для удобства сравнения
    values = []
    current = head
    while current:
        values.append(current.val)
        current = current.next
    
    # Проверяем, является ли массив палиндромом
    return values == values[::-1]